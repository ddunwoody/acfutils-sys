/* automatically generated by rust-bindgen 0.65.1 */

pub const RAD2DEG_RATIO: f64 = 0.017453292519943295;
pub const DEG2RAD_RATIO: f64 = 57.29577951308232;
pub const EARTH_MSL: u32 = 6371200;
pub type va_list = __builtin_va_list;
pub type bool_t = ::std::os::raw::c_uint;
pub type logfunc_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn log_init(func: logfunc_t, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn log_fini();
}
extern "C" {
    pub fn log_impl(
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn log_impl_v(
        filename: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn log_backtrace(skip_frames: ::std::os::raw::c_int);
}
extern "C" {
    pub fn crc64_init();
}
extern "C" {
    pub fn crc64_append(crc: u64, input: *const ::std::os::raw::c_void, sz: usize) -> u64;
}
extern "C" {
    pub fn crc64(input: *const ::std::os::raw::c_void, sz: usize) -> u64;
}
extern "C" {
    pub fn crc64_srand(seed: u64);
}
extern "C" {
    pub fn crc64_rand() -> u64;
}
extern "C" {
    pub fn crc64_rand_fract() -> f64;
}
extern "C" {
    pub fn crc64_rand_normal(sigma: f64) -> f64;
}
#[doc = " Geographic (spherical) coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geo_pos3_t {
    #[doc = "< degrees, increasing north"]
    pub lat: f64,
    #[doc = "< degrees, increasing east"]
    pub lon: f64,
    #[doc = "< meters or feet, increasing away from MSL"]
    pub elev: f64,
}
#[test]
fn bindgen_test_layout_geo_pos3_t() {
    const UNINIT: ::std::mem::MaybeUninit<geo_pos3_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<geo_pos3_t>(),
        24usize,
        concat!("Size of: ", stringify!(geo_pos3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<geo_pos3_t>(),
        8usize,
        concat!("Alignment of ", stringify!(geo_pos3_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos3_t),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lon) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos3_t),
            "::",
            stringify!(lon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos3_t),
            "::",
            stringify!(elev)
        )
    );
}
#[doc = " Simplified version of \\ref geo_pos3_t without an elevation component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geo_pos2_t {
    #[doc = "< degrees, increasing north"]
    pub lat: f64,
    #[doc = "< degrees, increasing east"]
    pub lon: f64,
}
#[test]
fn bindgen_test_layout_geo_pos2_t() {
    const UNINIT: ::std::mem::MaybeUninit<geo_pos2_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<geo_pos2_t>(),
        16usize,
        concat!("Size of: ", stringify!(geo_pos2_t))
    );
    assert_eq!(
        ::std::mem::align_of::<geo_pos2_t>(),
        8usize,
        concat!("Alignment of ", stringify!(geo_pos2_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos2_t),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lon) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos2_t),
            "::",
            stringify!(lon)
        )
    );
}
#[doc = " More compact version of \\ref geo_pos3_t using single-precision\n floating point coordinates to save a bit on memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geo_pos3_32_t {
    #[doc = "< degrees, increasing north"]
    pub lat: f32,
    #[doc = "< degrees, increasing east"]
    pub lon: f32,
    #[doc = "< meters or feet, increasing away from MSL"]
    pub elev: f32,
}
#[test]
fn bindgen_test_layout_geo_pos3_32_t() {
    const UNINIT: ::std::mem::MaybeUninit<geo_pos3_32_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<geo_pos3_32_t>(),
        12usize,
        concat!("Size of: ", stringify!(geo_pos3_32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<geo_pos3_32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(geo_pos3_32_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos3_32_t),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lon) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos3_32_t),
            "::",
            stringify!(lon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos3_32_t),
            "::",
            stringify!(elev)
        )
    );
}
#[doc = " More compact version of \\ref geo_pos2_t using single-precision\n floating point coordinates to save a bit on memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geo_pos2_32_t {
    #[doc = "< degrees, increasing north"]
    pub lat: f32,
    #[doc = "< degrees, increasing east"]
    pub lon: f32,
}
#[test]
fn bindgen_test_layout_geo_pos2_32_t() {
    const UNINIT: ::std::mem::MaybeUninit<geo_pos2_32_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<geo_pos2_32_t>(),
        8usize,
        concat!("Size of: ", stringify!(geo_pos2_32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<geo_pos2_32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(geo_pos2_32_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos2_32_t),
            "::",
            stringify!(lat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lon) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(geo_pos2_32_t),
            "::",
            stringify!(lon)
        )
    );
}
#[doc = " A generic 3-space vector. Looking down onto a plane embedded in euclidian\n 3-space, the axes are:\n x: left-to-right (increasing right)\n y: down-to-up (increasing up)\n z: away-towards viewer (increasing towards viewer)\n```\n\t\t\tY (incr up)\n\t\t\t^\n\t\t\t|\n\t\t\t|\n\t\t\t|\n\t\t\tx-------->\n\t\t\tZ        X (incr right)\n\t(incr towards us)\n```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vect3_t {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_vect3_t() {
    const UNINIT: ::std::mem::MaybeUninit<vect3_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vect3_t>(),
        24usize,
        concat!("Size of: ", stringify!(vect3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vect3_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vect3_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3_t),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " Same as \\ref vect3_t, but using extended precision double values."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct vect3l_t {
    pub x: u128,
    pub y: u128,
    pub z: u128,
}
#[test]
fn bindgen_test_layout_vect3l_t() {
    const UNINIT: ::std::mem::MaybeUninit<vect3l_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vect3l_t>(),
        48usize,
        concat!("Size of: ", stringify!(vect3l_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vect3l_t>(),
        16usize,
        concat!("Alignment of ", stringify!(vect3l_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3l_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3l_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vect3l_t),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " Generic 2-space vector. On euclidian 2-space, axes are:\n x: left-to-right (increasing right)\n y: down-to-up (increasing up)\n```\n Y (incr up)\n ^\n |\n |\n |\n +------->\n         X (incr right)\n```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vect2_s {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_vect2_s() {
    const UNINIT: ::std::mem::MaybeUninit<vect2_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vect2_s>(),
        16usize,
        concat!("Size of: ", stringify!(vect2_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vect2_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vect2_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vect2_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vect2_s),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " Generic 2-space vector. On euclidian 2-space, axes are:\n x: left-to-right (increasing right)\n y: down-to-up (increasing up)\n```\n Y (incr up)\n ^\n |\n |\n |\n +------->\n         X (incr right)\n```"]
pub type vect2_t = vect2_s;
#[doc = " Ellipsoid parameters. Ellipsoids are often used to translate between\n geographic coordinates and 3-space Euclidian coordinate systems, such\n as ECEF. The vast majority of the time, you will simply want to use\n the standard \\ref wgs84 ellipsoid.\n\n @see fpp_init()\n @see geo2ecef_mtr()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ellip_t {
    #[doc = "< Semi-major axis of the ellipsoid in meters"]
    pub a: f64,
    #[doc = "< Semi-minor axis of the ellipsoid in meters"]
    pub b: f64,
    #[doc = "< Flattening"]
    pub f: f64,
    #[doc = "< First eccentricity"]
    pub ecc: f64,
    #[doc = "< First eccentricity squared"]
    pub ecc2: f64,
    #[doc = "< Mean radius in meters"]
    pub r: f64,
}
#[test]
fn bindgen_test_layout_ellip_t() {
    const UNINIT: ::std::mem::MaybeUninit<ellip_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ellip_t>(),
        48usize,
        concat!("Size of: ", stringify!(ellip_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ellip_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ellip_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ellip_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ellip_t),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ellip_t),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ellip_t),
            "::",
            stringify!(ecc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecc2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ellip_t),
            "::",
            stringify!(ecc2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ellip_t),
            "::",
            stringify!(r)
        )
    );
}
#[doc = " Object used to hold bezier curves. Create using bezier_alloc() and\n free using bezier_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bezier_t {
    pub n_pts: usize,
    pub pts: *mut vect2_t,
}
#[test]
fn bindgen_test_layout_bezier_t() {
    const UNINIT: ::std::mem::MaybeUninit<bezier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bezier_t>(),
        16usize,
        concat!("Size of: ", stringify!(bezier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bezier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bezier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_pts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bezier_t),
            "::",
            stringify!(n_pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bezier_t),
            "::",
            stringify!(pts)
        )
    );
}
extern "C" {
    pub static wgs84: ellip_t;
}
extern "C" {
    pub fn is_on_arc(angle_x: f64, angle1: f64, angle2: f64, cw: bool_t) -> bool_t;
}
extern "C" {
    pub fn rel_angle(a1: f64, a2: f64) -> f64;
}
extern "C" {
    pub fn vect3_abs(a: vect3_t) -> f64;
}
extern "C" {
    pub fn vect3_dist(a: vect3_t, b: vect3_t) -> f64;
}
extern "C" {
    pub fn vect2_abs(a: vect2_t) -> f64;
}
extern "C" {
    pub fn vect2_dist(a: vect2_t, b: vect2_t) -> f64;
}
extern "C" {
    pub fn vect3_set_abs(a: vect3_t, abs: f64) -> vect3_t;
}
extern "C" {
    pub fn vect2_set_abs(a: vect2_t, abs: f64) -> vect2_t;
}
extern "C" {
    pub fn vect3_unit(a: vect3_t, l: *mut f64) -> vect3_t;
}
extern "C" {
    pub fn vect2_unit(a: vect2_t, l: *mut f64) -> vect2_t;
}
extern "C" {
    pub fn vect3_add(a: vect3_t, b: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn vect2_add(a: vect2_t, b: vect2_t) -> vect2_t;
}
extern "C" {
    pub fn vect3_sub(a: vect3_t, b: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn vect2_sub(a: vect2_t, b: vect2_t) -> vect2_t;
}
extern "C" {
    pub fn vect3_mul(a: vect3_t, b: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn vect2_mul(a: vect2_t, b: vect2_t) -> vect2_t;
}
extern "C" {
    pub fn vect3_scmul(a: vect3_t, b: f64) -> vect3_t;
}
extern "C" {
    pub fn vect2_scmul(a: vect2_t, b: f64) -> vect2_t;
}
extern "C" {
    pub fn vect3_dotprod(a: vect3_t, b: vect3_t) -> f64;
}
extern "C" {
    pub fn vect2_dotprod(a: vect2_t, b: vect2_t) -> f64;
}
extern "C" {
    pub fn vect3_xprod(a: vect3_t, b: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn vect3_mean(a: vect3_t, b: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn vect2_mean(a: vect2_t, b: vect2_t) -> vect2_t;
}
extern "C" {
    pub fn vect2_norm(v: vect2_t, right: bool_t) -> vect2_t;
}
extern "C" {
    pub fn vect3_rot(v: vect3_t, angle: f64, axis: ::std::os::raw::c_uint) -> vect3_t;
}
extern "C" {
    pub fn vect2_rot(v: vect2_t, angle: f64) -> vect2_t;
}
extern "C" {
    pub fn vect2_rot_inv_y(v: vect2_t, angle: f64) -> vect2_t;
}
extern "C" {
    pub fn vect3_neg(v: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn vect2_neg(v: vect2_t) -> vect2_t;
}
extern "C" {
    pub fn vect3_local2acf(v: vect3_t, roll: f64, pitch: f64, hdgt: f64) -> vect3_t;
}
extern "C" {
    pub fn vect3_acf2local(v: vect3_t, roll: f64, pitch: f64, hdgt: f64) -> vect3_t;
}
extern "C" {
    pub fn ellip_init(semi_major: f64, semi_minor: f64, flattening: f64) -> ellip_t;
}
extern "C" {
    pub fn geo2sph(pos: geo_pos3_t, ellip: *const ellip_t) -> geo_pos3_t;
}
extern "C" {
    pub fn geo2ecef_mtr(pos: geo_pos3_t, ellip: *const ellip_t) -> vect3_t;
}
extern "C" {
    pub fn geo2ecef_ft(pos: geo_pos3_t, ellip: *const ellip_t) -> vect3_t;
}
extern "C" {
    pub fn ecef2geo(pos: vect3_t, ellip: *const ellip_t) -> geo_pos3_t;
}
extern "C" {
    pub fn ecef2sph(v: vect3_t) -> geo_pos3_t;
}
extern "C" {
    pub fn sph2ecef(pos: geo_pos3_t) -> vect3_t;
}
extern "C" {
    pub fn ecef2gl(ecmi: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn gl2ecef(opengl: vect3_t) -> vect3_t;
}
extern "C" {
    pub fn geo2ecmi(pos: geo_pos3_t, delta_t: f64, ellip: *const ellip_t) -> vect3_t;
}
extern "C" {
    pub fn ecmi2geo(pos: vect3_t, delta_t: f64, ellip: *const ellip_t) -> geo_pos3_t;
}
extern "C" {
    pub fn sph2ecmi(pos: geo_pos3_t, delta_t: f64) -> vect3_t;
}
extern "C" {
    pub fn ecmi2sph(pos: vect3_t, delta_t: f64) -> geo_pos3_t;
}
extern "C" {
    pub fn ecef2ecmi(ecef: vect3_t, delta_t: f64) -> vect3_t;
}
extern "C" {
    pub fn ecmi2ecef(ecmi: vect3_t, delta_t: f64) -> vect3_t;
}
extern "C" {
    pub fn vect2sph_isect(
        v: vect3_t,
        o: vect3_t,
        c: vect3_t,
        r: f64,
        confined: bool_t,
        i: *mut vect3_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn vect2circ_isect(
        v: vect2_t,
        o: vect2_t,
        c: vect2_t,
        r: f64,
        confined: bool_t,
        i: *mut vect2_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn vect2vect_isect(
        da: vect2_t,
        oa: vect2_t,
        db: vect2_t,
        ob: vect2_t,
        confined: bool_t,
    ) -> vect2_t;
}
extern "C" {
    pub fn circ2circ_isect(
        ca: vect2_t,
        ra: f64,
        cb: vect2_t,
        rb: f64,
        i: *mut vect2_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn vect2poly_isect_get(
        a: vect2_t,
        oa: vect2_t,
        poly: *const vect2_t,
        isects: *mut vect2_t,
        cap: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn vect2poly_isect(a: vect2_t, oa: vect2_t, poly: *const vect2_t)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn point_in_poly(pt: vect2_t, poly: *const vect2_t) -> bool_t;
}
extern "C" {
    pub fn hdg2dir(truehdg: f64) -> vect2_t;
}
extern "C" {
    pub fn dir2hdg(dir: vect2_t) -> f64;
}
extern "C" {
    pub fn geo_displace(
        ellip: *const ellip_t,
        pos: geo_pos2_t,
        truehdg: f64,
        dist: f64,
    ) -> geo_pos2_t;
}
extern "C" {
    pub fn geo_displace_dir(
        ellip: *const ellip_t,
        pos: geo_pos2_t,
        dir: vect2_t,
        dist: f64,
    ) -> geo_pos2_t;
}
extern "C" {
    pub fn geo_pos2_from_str(
        lat: *const ::std::os::raw::c_char,
        lon: *const ::std::os::raw::c_char,
        pos: *mut geo_pos2_t,
    ) -> bool_t;
}
extern "C" {
    pub fn geo_pos3_from_str(
        lat: *const ::std::os::raw::c_char,
        lon: *const ::std::os::raw::c_char,
        elev: *const ::std::os::raw::c_char,
        pos: *mut geo_pos3_t,
    ) -> bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sph_xlate_t {
    pub sph_matrix: [f64; 9usize],
    pub rot_matrix: [f64; 4usize],
    pub inv: bool_t,
}
#[test]
fn bindgen_test_layout_sph_xlate_t() {
    const UNINIT: ::std::mem::MaybeUninit<sph_xlate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sph_xlate_t>(),
        112usize,
        concat!("Size of: ", stringify!(sph_xlate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sph_xlate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sph_xlate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sph_matrix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sph_xlate_t),
            "::",
            stringify!(sph_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rot_matrix) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sph_xlate_t),
            "::",
            stringify!(rot_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inv) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sph_xlate_t),
            "::",
            stringify!(inv)
        )
    );
}
extern "C" {
    pub fn sph_xlate_init(displacement: geo_pos2_t, rotation: f64, inv: bool_t) -> sph_xlate_t;
}
extern "C" {
    pub fn sph_xlate(pos: geo_pos2_t, xlate: *const sph_xlate_t) -> geo_pos2_t;
}
extern "C" {
    pub fn sph_xlate_vect(pos: vect3_t, xlate: *const sph_xlate_t) -> vect3_t;
}
extern "C" {
    pub fn gc_distance(start: geo_pos2_t, end: geo_pos2_t) -> f64;
}
extern "C" {
    pub fn gc_point_hdg(start: geo_pos2_t, end: geo_pos2_t) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpp_t {
    pub ellip: *const ellip_t,
    pub xlate: sph_xlate_t,
    pub inv_xlate: sph_xlate_t,
    pub allow_inv: bool_t,
    pub dist: f64,
    pub scale: vect2_t,
}
#[test]
fn bindgen_test_layout_fpp_t() {
    const UNINIT: ::std::mem::MaybeUninit<fpp_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fpp_t>(),
        264usize,
        concat!("Size of: ", stringify!(fpp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<fpp_t>(),
        8usize,
        concat!("Alignment of ", stringify!(fpp_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ellip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpp_t),
            "::",
            stringify!(ellip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xlate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpp_t),
            "::",
            stringify!(xlate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inv_xlate) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(fpp_t),
            "::",
            stringify!(inv_xlate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_inv) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(fpp_t),
            "::",
            stringify!(allow_inv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dist) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(fpp_t),
            "::",
            stringify!(dist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(fpp_t),
            "::",
            stringify!(scale)
        )
    );
}
extern "C" {
    pub fn fpp_init(
        center: geo_pos2_t,
        rot: f64,
        dist: f64,
        ellip: *const ellip_t,
        allow_inv: bool_t,
    ) -> fpp_t;
}
extern "C" {
    pub fn ortho_fpp_init(
        center: geo_pos2_t,
        rot: f64,
        ellip: *const ellip_t,
        allow_inv: bool_t,
    ) -> fpp_t;
}
extern "C" {
    pub fn gnomo_fpp_init(
        center: geo_pos2_t,
        rot: f64,
        ellip: *const ellip_t,
        allow_inv: bool_t,
    ) -> fpp_t;
}
extern "C" {
    pub fn stereo_fpp_init(
        center: geo_pos2_t,
        rot: f64,
        ellip: *const ellip_t,
        allow_inv: bool_t,
    ) -> fpp_t;
}
extern "C" {
    pub fn geo2fpp(pos: geo_pos2_t, fpp: *const fpp_t) -> vect2_t;
}
extern "C" {
    pub fn fpp2geo(pos: vect2_t, fpp: *const fpp_t) -> geo_pos2_t;
}
extern "C" {
    pub fn fpp_set_scale(fpp: *mut fpp_t, scale: vect2_t);
}
extern "C" {
    pub fn fpp_get_scale(fpp: *const fpp_t) -> vect2_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcc_t {
    pub reflat: f64,
    pub reflon: f64,
    pub n: f64,
    pub F: f64,
    pub rho0: f64,
}
#[test]
fn bindgen_test_layout_lcc_t() {
    const UNINIT: ::std::mem::MaybeUninit<lcc_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lcc_t>(),
        40usize,
        concat!("Size of: ", stringify!(lcc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lcc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lcc_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lcc_t),
            "::",
            stringify!(reflat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reflon) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lcc_t),
            "::",
            stringify!(reflon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(lcc_t), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).F) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(lcc_t), "::", stringify!(F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rho0) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lcc_t),
            "::",
            stringify!(rho0)
        )
    );
}
extern "C" {
    pub fn lcc_init(reflat: f64, reflon: f64, stdpar1: f64, stdpar2: f64) -> lcc_t;
}
extern "C" {
    pub fn geo2lcc(pos: geo_pos2_t, lcc: *const lcc_t) -> vect2_t;
}
extern "C" {
    pub fn bezier_alloc(num_pts: usize) -> *mut bezier_t;
}
extern "C" {
    pub fn bezier_free(curve: *mut bezier_t);
}
extern "C" {
    pub fn quad_bezier_func(x: f64, func: *const bezier_t) -> f64;
}
extern "C" {
    pub fn quad_bezier_func_inv(y: f64, func: *const bezier_t, n_xs: *mut usize) -> *mut f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mat4_t {
    pub _mat4_data: [f64; 16usize],
}
#[test]
fn bindgen_test_layout_mat4_t() {
    const UNINIT: ::std::mem::MaybeUninit<mat4_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mat4_t>(),
        128usize,
        concat!("Size of: ", stringify!(mat4_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mat4_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mat4_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mat4_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mat4_t),
            "::",
            stringify!(_mat4_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mat3_t {
    pub _mat3_data: [f64; 9usize],
}
#[test]
fn bindgen_test_layout_mat3_t() {
    const UNINIT: ::std::mem::MaybeUninit<mat3_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mat3_t>(),
        72usize,
        concat!("Size of: ", stringify!(mat3_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mat3_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mat3_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mat3_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mat3_t),
            "::",
            stringify!(_mat3_data)
        )
    );
}
extern "C" {
    pub fn mat4_ident(mat: *mut mat4_t);
}
extern "C" {
    pub fn mat3_ident(mat: *mut mat3_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
